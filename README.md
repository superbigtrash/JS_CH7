7 - 1 : 스태틱 메서드, 프로토타입 메서드
  스태틱 메서드란 어떤 인스턴스에서 직접 접근할 수 없는 메서드를 스태틱 메서드라고 하고, 프로토타입 메서드란 어떤 인스턴스에서 직접 호출할 수 있는 메서드를 말한다. isRectangle이 스태틱 메서드이고, getArea가 프로토타입 메서드이다. 예시로써 rect1인스턴스가 스태틱 메서드를 실행하려고 하면 에러가 나오는 것을 확인할 수 있다.

7 - 2 : 6 - 2 - 4절의 Grade 생성자 함수 및 인스턴스
  ES5까지의 자바스크립트는 클래스가 없다. 그 이후버전인 ES6는 클래스가 도입되었다. 하지만 이는 prototype을 기반으로 한 것으로 프로토타입 체이닝을 잘 연결한 것으로 이해하면 된다. 세부적으로 부모와 자식 클래스의 구현이 완벽하게 이뤄진 것은 아니다. 위 예제를 예시로 든다면 length프로퍼티가 삭제가능하다는 점과 Grade.prototype에 빈 배열을 참조시켰다는 점이 그렇다.

7 - 3 : length 프로퍼티를 삭제한 경우
  예제 7 - 2를 이어쓴 코드이다. 배열의 prototype 메서드인 push를 통해 3번째 인덱스 자리에 90을 추가하고 length를 삭제하고 다시 push를 사용한 결과 첫번째 인덱스 자리에 70이 들어갔고, length는 1이 되었다. 이는 내장객체인 배열 인스턴스의 length 프로퍼티는 삭제가 불가능하지만, Grade 클래스의 인스턴스는 배열 메서드를 상속하지만 일반 객체의 성질을 그대로 지니므로 삭제가 가능하기 때문에 문제가 발생한 것이다.

7 - 4 : 요소가 있는 배열을 prototype에 매칭한 경우
  이번에는 Grade.prototype이 빈 배열이 아닌 ['a', 'b', 'c', 'd']배열을 가리키도록 하였다. 그 이후의 코드는 같지만 동작방식이 살짝 달라진 것을 출력 결과를 통해 확인할 수 있다. 12번째 줄부터 g.length를 삭제하지만 객체의 길이는 달라지지 않으므로 push가 4번째 인덱스에 70을 추가하여 length는 5가 되는 것을 확인할 수 있다.

7 - 5 : Rectangle, Square 클래스
  직사각형과 정사각형의 길이를 넘겨 각각의 넓이를 구하게 해주는 클래스를 선언하는 예제이다. 넓이를 구하는 공식은 결국 한변 곱하기 한변이기 때문에 이를 공통으로 묶어주려고 한다.

7 - 6 : Square 클래스 변형
  예제 제목 그대로 Square 클래스를 변형하였다. 원래 width만 쓰였지만 height도 추가된 상태이다. getArea도 마찬가지로 width * width에서 width * height로 변경되었다.

7 - 7 : Rectangle을 상속하는 Square 클래스
  이번에도 Square 클래스를 변형하였다. 내부에 this를 이용해 길이를 넘겨주는 대신 Rectangle.call함수를 이용해 넘겨받는 코드이다. 또한 Square 인스턴스가 생성될 때에도 Rectangle 생성자를 이용이 되는 것을 확인할 수 있다.

7 - 8 : 클래스 상속 및 추상화 방법(1) - 인스턴스 생성 후 프로퍼티 제거
  클래스가 구체적인 데이터를 지니지 않게 하는 방법, 첫 번째로 일단 객체를 만들고 나서 프로퍼티들을 일일이 지우고 더는 새로운 프로퍼티를 추가할 수 없게 하는 것이다. exntendClass1함수는 부모클래스, 자식클래스, sub메서드를 인자로 받는데 부모클래스가 자식클래스를 바라보도록하고 자식클래스의 프로퍼티를 지우고, 새로운 프로퍼티를 추가할 수 없도록 freeze함수를 사용하고 있다.

7 - 9 : 클래스 상송 및 추상화 방법(2) - 빈 함수를 활용
  클래스가 구체적인 데이터를 지니지 않게 하는 방법, 두 번째로 자식클래스의 프로토타입에 직접 부모클래스의 인스턴스를 할당하는 대신 아무런 프로퍼티를 생성하지 않는 빈 생성자 함수를 하나 더 만들어서 그 프로토타입이 부모클래스의 프로토타입을 바라보게 한 다음, 자식클래스의 프로토타입에는 빈 생성자 함수의 인스턴스를 할당하게 하는 것이다. 위 말 그대로 빈 생성자 함수인 Bridge를 만들고 이를 Rectangle프로토타입을 바라보게 한다음, 자식클래스인 Square를 Bridge의 인스턴스를 할당하게 하였다.

7 - 10 : 클래스 상속 및 추상화 방법(3) - Object.create활용
  클래스가 구체적인 데이터를 지니지 않게 하는 방법, 세 번째로 ES5에서 도입된 Object.create를 이용한 방법이다. 이 방법은 자식클래스의 프로토타입의 __proto__가 부모클래스의 프로토타입을 바라보되, 부모클래스의 인스턴스가 되지 않게하는 방법이다.

7 - 11 : 클래스 상속 및 추상화 방법 - 완성본(1) - 인스턴스 생성 후 프로퍼티 제거
  7 - 8, 9, 10모두 상속에는 성공하였지만 자식클래스 인스턴스의 constructor는 여전히 부모클래스를 가리키는 상태이다. 자식클래스인스턴스에는 constructor가 없고, 자식클래스의 프로토타입에도 없는 상태이다. 프로토타입 체인상에 가장 먼저 등장하는 부모클래스의 프로토타입의 constructor에서 가리키는 대상인 부모클래스만 출력이 될 뿐이다. 따라서 자식클래스의 프로토타입의 constructor가 원래의 자식클래스를 바라보도록 해주면 된다. 이를 반영한 코드이다. 8번째 줄이 SubClass.prototype.constructor = SubClass 추가된 코드이다. 

7 - 12 : 클래스 상속 및 추상화 방법 - 완성본(2) - 빈 함수를 활용
  이번에는 빈 함수(Bridge)를 이용한 코드이다. 빈 함수의 프로토타입이 부모클래스의 프로토타입을 바라보게 하고, 자식클래스의 프로토타입에는 빈 함수의 인스턴스를 할당하게 하였다. 또한 SubClass.prototype.constructor = SubClass이 6번째 줄에 추가되었다. 이로써 constructor가 원래의 자식클래스를 바라보도록하게 된다. 

7 - 13 : 클래스 상속 및 추상화 방법 - 완성본(3) - Object.create 활용
  마찬가지로 Object.create함수를 활용하고 SubClass.prototype.constructor = SubClass를 추가하여 자식클래스의 constructor가 원래의 자식클래스를 바라보도록하게 하였다.

7 - 14 : 상위 클래스 접근 수단인 super 메서드 추가
  위 코드는 7 - 13의 코드를 수정한 코드이다. 하위 클래스에서 상위 클래스의 어떤 결과값을 이용하기위해 만들어진 코드이다.
  extendClass함수 내부에 자식클래스의 프로토타입의 메서드로 super라는 메서드를 추가하였다. 인자가 비었을 경우 부모클래스 생성자 함수에 접근하는 것으로 간주하고, this가 달라지는 것을 막기 위해 클로저를 사용하였다. 부모클래스의 프로토타입 내부의 propName에 해당하는 값이 함수가 아닌 경우 해당 값을 그대로 반환하게 하였고, 11번째 줄은 함수인 경우이므로 클로절르 활용해 메서드에 접근하는 것으로 여기도록 하였다. 사용법은 부모클래스의 생성자 함수에 접근하고자 할 때는 this.super(), 부모클래스의 프로토타입 메서드에 접근하고자 할 때는 this.super(propName)와 같이 사용하면 된다.
  
7 - 15 : ES5 와 ES6의 클래스 문법 비교
  ES6를 ES5와 비교해보았을 때 편리성이 더 강화된 것 같다. ES5에서 함수호출시 예를들면 ES5.staticMethod, ES5.prototype.method등 이름이 점점 길어져 가독성이 떨어질수 있는 반면, ES6는 간결하게 static의 유무와 함수명만 쓰면 된다.

7 - 16 : ES6의 클래스 상속
  상속문제도 간단히 자식클래스 = class extneds 부모클래스를 쓰면 간단히 해결된다.
